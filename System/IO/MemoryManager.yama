namespace "System.IO"
{
    using "System";

    public static class MemoryManager
    {

        // -----------------------------------------------

        #region methods

        // -----------------------------------------------

        /**
         * Dynamic memory allocate
         *
         * @param[in] size (Int) The size to reserved
         *
         * @return (Int) The Adress of the Object (If this is null then is failed and not engough space exist)
         */
        public static int Malloc ( int size )
        {
            #defalgo Malloc,Init:

            int currentadress;
            int currentBlockState;
            int currentBlockSize;
            int nextAdress = #defalgo Malloc,CurrentAdress:;

            while ( true )
            {
                currentadress = nextAdress;

                currentBlockState = #defalgo Malloc,GetBlockState: = currentadress;
                currentBlockSize = #defalgo Malloc,GetBlockSize: = currentadress;

                nextAdress = #defalgo Malloc,GetNextAdress: = currentadress;

                if (#defalgo Malloc,IsBlockInUse:=currentadress) continue;

                if (size <= currentBlockSize) break;

                if (#defalgo Malloc,IsBlockEnde:=currentadress) return null;
            }

            return MemoryManager.ReservedNewBlock ( currentadress, size, currentBlockState );
        }

        // -----------------------------------------------

        private static int ReservedNewBlock ( int currentadress, int size, int nextBlockState )
        {
            MemoryManager.CreateBlock ( currentadress, 0, size );

            currentadress = currentadress + #defalgo Malloc,HeaderSize:;

            if (currentBlockState == 0) return currentadress;

            int nextAdress = currentadress + size;
            size = size + #defalgo Malloc,HeaderSize:;
            size = currentBlockSize - size;

            MemoryManager.CreateBlock ( nextAdress, 1, size );

            return currentadress;
        }

        // -----------------------------------------------

        private static int CreateBlock ( int adresse, int blockState, int size )
        {

            #defalgo Malloc,SetBlockAdresse: = adresse;

            #defalgo Malloc,SetBlockState: = blockState;

            #defalgo Malloc,SetBlockSize: = size;

        }

        // -----------------------------------------------

        /**
        * Get the Size of Object instance in Memory
        *
        * @param[int] Adress (int) The object adress
        *
        * @return (int) Size of the object, without Header
        */
        public static int SizeOf ( int adresse )
        {
            if (adresse == null) return null;

            adresse = adresse - 3;

            return #defalgo Malloc,GetBlockSize: = adresse;
        }

        // -----------------------------------------------

        /**
         * Dynamic memory allocate Free
         *
         * @param[in] Adress (Int) The object adress
         *
         * @return (Bool) true is Ok and false is not ok
         */
        public static bool Free ( int addresse )
        {
            if (addresse == null) return null;

            #defalgo MallocFree,default: = addresse;

            return MemoryManager.Clean ( addresse );
        }

        // -----------------------------------------------

        /**
         * Clean Memory Blocks
         */
        private static bool Clean ( int addresse )
        {
            #defalgo Malloc,Init:

            int currentadress = #defalgo Malloc,CurrentAdress:;

            while ( currentadress < addresse )
            {
                currentadress = #defalgo Malloc,CurrentAdress:;

                #defalgo MallocClean, default: = currentadress;
            }

            return true;
        }

        // -----------------------------------------------

        #endregion methods

        // -----------------------------------------------

    }
}

// --[EOF]--